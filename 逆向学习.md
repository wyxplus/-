## 寄存器详解大全

![register](C:\Users\myuser\Desktop\新建文件夹\register.jpg)

### 1. 通用寄存器

#### AX (Accumulator)：累加寄存器，也称之为累加器；

其可以在使用 DIV 和 MUL 指令时使用

- DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的。除数可以存放在寄存器中或者是内存单元中，**被除数放在 AX 中**。当除数是 8 位时，**被除数** 一定会是 16 位的，并且**默认放在 AX 寄存器**中；而当除数是 16 位时，**被除数**一定是 32 位的，其中**高 16 位**放到 **DX** 中，**低 16 位**放在 **AX** 中。当除法指令执行完成以后，如果除数是 8 位的，则在 **AL** 中会保存此次除法操作的**商**，而在 **AH** 中则会保存此次除法操作的**余数**；如果除数是 16 位的话，则 **AX** 中会保存本次除法操作的**商**，而 **DX** 则保存本次除法操作的**余数**。
- MUL 在 8086 CPU 中是乘法指令，在做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位。如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中；而如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个则是某个寄存器中或者是某个内存字单元中。当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中；如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，其中高位默认保存在 DX 中，而低位则默认保存在 AX 中。

> 注：
>
> 乘法：默认放一个在 AL/AX，超过寄存器存放结果高的位在 DX，低位在 AX，反之直接放在 AX。
>
> 除法：被除数默认放在AL、AX、（高位）DX AX（低位）。商 AL、AX，余数 AH、DX。

#### BX (Base)：基地址寄存器；

寻址(物理内存地址)上。8086中的地址表示是 **段地址:[偏移]**，段地址可省略，省略时取默认情况。

#### CX (Count)：计数器寄存器；

当在汇编指令中使用循环 LOOP 指令时，可以通过 CX 来指定需要循环的次数。如果 CX 中的值为 0 则会跳出循环。

#### DX (Data)：数据寄存器；

当在使用 DIV 指令进行除法运算时，如果除数为 16 位时，被除数将会是 32 位，而被除数的高 16 位就是存放在 DX 中，执行完 DIV 指令后，本次除法运算所产生的余数将会保存在 DX 中；在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，相乘后产生的结果显然需要 32 位来保存，而这 32 位的结果的高 16 位就是存放在 DX 寄存器中。



### 2. 指针寄存器

#### SP (Stack Pointer)：堆栈指针寄存器；

SS:SP 两个寄存器指向的是内存栈的栈顶元素。当使用 PUSH 指令向栈中压入 1 个字节单元时，SP =SP - 1；即栈顶元素会发生变化；当使用 POP 指令从栈中弹出 1 个字节单元时， SP =SP + 1；即栈顶元素会发生变化。

 

#### BP (Base Pointer)：帧指针/基指针寄存器；

BP也就是基指针寄存器，它和其他的几个用来进行寻址操作所使用的寄存器(还有 BX，SI，DI)没有太大的区别。首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用。

当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，如果在指令中**没有明确或者说是显示的给出段地址时, 段地址使用默认的 SS 寄存器中的值(BX，SI，DI 会默认使用 DS 段寄存器)。**比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元；而如果是仅使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。



### 3. 变址寄存器

首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。

#### SI (Source Index)：源变址寄存器；

#### DI (Destination Index)：目的变址寄存器；



### 4. 其他寄存器

#### CS (Code Segment)：代码段寄存器；

#### IP (Instruction Pointer)：指令指针寄存器；

CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 CS 为代码段寄存器，而 IP 为指令指针寄存器 。**当一个可执行文件加载到内存中以后，CS:IP 两个寄存器便指向了这个可执行文件的起始地址**，然后 CPU 就可以从这个起始地址开始往下读取指令，当读取完指令后，CS:IP 将会自动的改变，基本上是改变 IP，从而指向下一条要读取的指令，这样就可以执行这个可执行文件了。任何时候，CS:IP 指向的地址中的内容都是 CPU 当前执行的指令。

 

#### SS (Stack Segment)：堆栈段寄存器；

SS:SP 两个寄存器指向的是内存栈的栈顶元素。当使用 PUSH 指令向栈中压入 1 个字节单元时，SP =SP - 1；即栈顶元素会发生变化；当使用 POP 指令从栈中弹出 1 个字节单元时， SP =SP + 1；即栈顶元素会发生变化。

 



#### FLAG：标志寄存器；





#### DS (Data Segment)：数据段寄存器；

#### ES (Extra Segment)：附加段寄存器；





## 2. 操作码

### 1. lea

lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：
lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。

而mov指令则恰恰相反，例如：
mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。



### 2. cdq

 这个指令把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上。 它大多出现在除法运算之前。它实际的作用只是把EDX的所有位都设成EAX最高位的值。也就是说，当EAX <80000000, EDX 为00000000；当EAX >= 80000000， EDX 则为FFFFFFFF。
cdq的作用是将一个32位有符号数扩展为64位有符号数，扩展高位。



### 3. shl 和 shr

逻辑左移、逻辑右移

（1）将一个寄存器或内存单元中的数据向左移位；

（2）将最后移出的一位写入 CF 中；

（3）最低位用 0 补充。



#### 4. sal 和 sar

算数左移、算数右移

SAL（算术左移）指令的操作与 SHL 指令一样。每次移动时，SAL 都将目的操作数中的每一位移动到下一个最高位上。最低位用 0 填充；最高位移入进位标志位，该标志位原来的值被丢弃：

### 4. lea

有没有 [ ] 对于变量是无所谓的，其结果都是取变量的地址，相当于指针（与mov相反）



#### 5. idiv 和 div

有符号除法和无符号除法。



## trick

1. C++ 字符串在内存中以 00（Hex） 结尾。

2. 获得windows API 是在 https://docs.microsoft.com/en-us/previous-versions//hh447209(v=vs.85)?redirectedfrom=MSDN

3. opCode：在 X86 平台下使用的汇编指令对应的二进制机器码为 Intel 指令集。

   | 指令前缀             | 指令操作码 | 操作数类型 | 辅助操作数类型，计算地址偏移 | 立即数    |
   | -------------------- | ---------- | ---------- | ---------------------------- | --------- |
   | instruction Prefixes | Opcode     | Mode R/M   | SIB\|Displacement            | immediate |

   

4. 浮点数寄存器 ST(0) - ST(7) 8 个栈空间。

   IN 表示操作数入栈，OUT 表示出栈。

   FLD FILD FLDZ FLD1 FST FSTP FIST FISTP FCOM FTST FADD FADDP 



5. 原程序的 OEP，通常是一开始以 ``push ebp`` ​和 ​``mov ebp,esp​`` 这两句开始的。

   保护栈顶指针，子程序返回时直接 ``mov esp,ebp`` 就好，无需管栈的变化。



6. ASCII 一个字节表示一个字符，Unicode 两个字节表示一个字符。







7. 栈

   在子函数调用时，执行的操作有：父函数将调用参数从后向前压栈 -> 将返回地址压栈保存 -> 跳转到子函数起始地址执行 -> 子函数将父函数栈帧起始地址（%rpb） 压栈 -> 将 %rbp 的值设置为当前 %rsp 的值，即将 %rbp 指向子函数栈帧的起始地址。

   bp 主要在编写子程序时才用。因为子程序中经常使用局部变量，而**局部变量**的空间是在**堆栈上申请**的，这时就先让 bp=sp，然后每定义一个局部变量，就把它压入堆栈。等子程序结束时，只要简单地一句 mov sp, bp 就可以从堆栈找到原先的返回地址，同时也归还了局部变量所占的空间。然后用 ret 指令，顺利返回。 

   

![stack](C:\Users\myuser\Desktop\新建文件夹\stack.png)



计算机中的“堆栈宽度”是可以推入堆栈的最小数据量，被定义为处理器的寄存器大小。这意味着如果您正在处理具有 16 位寄存器的处理器，则堆栈宽度将为 2 个字节。如果处理器有 32 位寄存器，则堆栈宽度为 4 个字节。如果处理器有 64 位寄存器，则堆栈宽度为 8 个字节。

使用现代 x86 / x86_64 系统时不要混淆; 如果系统以 32 位模式运行，则堆栈宽度和寄存器大小为 32 位或 4 个字节。如果切换到 64 位模式，那么只有那时寄存器和堆栈大小才会改变。





8. ``#define`` 是真常量，``const`` 是假常量。``const`` 只在编译器中检查是否有被修改，因此可以获取该变量地址来修改被 ``const`` 修饰的变量。

9. main 或 WinMain 函数不是应用程序入口代码，通常是 mainCRTStartup、wmainCRTStartup、WinMainCRTStartup、wWinMainCRTStartup



10. 编译器优化

    1. 常量传播

       降编译期间**可计算出结果的变量**转换成**常量**。

       ``int a = 1; int b = a;`` => ``int a = 1; int b = 1;``

    2. 常量折叠

       计算中出现多个常量进行计算的情况，且编译期间计算出结果，所有常量计算都变转换成计算结果。

       ``int a = 1 + 2 + 3 + 4;`` => ``int a = 10;``

    使用常量的好处是可以生成立即数寻址的目标代码。常量作为立即数成为指令的一部分，减少访存次数。
